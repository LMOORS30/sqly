error: #[automatically_derived]
       impl ::sqly::Table for T1 {
           const AUTOMATICALLY_DERIVED: () = ();
       }
 --> tests/debug/table.rs:6:21
  |
6 | #[sqly(table = "t", debug)]
  |                     ^^^^^

error: #[allow(non_snake_case)]
       struct FlatT2;
       #[automatically_derived]
       impl ::sqly::Flat for T2 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Flat = FlatT2;
       }
       #[automatically_derived]
       impl ::sqly::Table for T2 {
           const AUTOMATICALLY_DERIVED: () = ();
       }
  --> tests/debug/table.rs:10:21
   |
10 | #[sqly(table = "t", debug, flat)]
   |                     ^^^^^

error: #[allow(non_snake_case)]
       struct FlatT3;
       #[automatically_derived]
       impl<'r> ::sqly::sqlx::FromRow<'r, ::sqly::sqlx::postgres::PgRow> for FlatT3 {
           fn from_row(row: &'r ::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<Self> {
               use ::sqly::sqlx::Row as _;
               ::sqly::sqlx::Result::Ok(FlatT3 {})
           }
       }
       #[automatically_derived]
       impl ::sqly::Flat for T3 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Flat = FlatT3;
       }
       #[automatically_derived]
       impl ::sqly::Table for T3 {
           const AUTOMATICALLY_DERIVED: () = ();
       }
  --> tests/debug/table.rs:14:21
   |
14 | #[sqly(table = "t", debug, flat, flat_row)]
   |                     ^^^^^

error: #[allow(non_snake_case)]
       struct FlatT4;
       #[automatically_derived]
       impl<'r> ::sqly::sqlx::FromRow<'r, ::sqly::sqlx::postgres::PgRow> for FlatT4 {
           fn from_row(row: &'r ::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<Self> {
               use ::sqly::sqlx::Row as _;
               ::sqly::sqlx::Result::Ok(FlatT4 {})
           }
       }
       #[automatically_derived]
       impl ::core::convert::From<FlatT4> for T4 {
           fn from(row: FlatT4) -> Self {
               T4 {}
           }
       }
       #[automatically_derived]
       impl ::sqly::Flat for T4 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Flat = FlatT4;
       }
       #[automatically_derived]
       impl ::sqly::Table for T4 {
           const AUTOMATICALLY_DERIVED: () = ();
       }
  --> tests/debug/table.rs:18:21
   |
18 | #[sqly(table = "t", debug, flat, flat_row, from_flat)]
   |                     ^^^^^

error: #[allow(non_snake_case)]
       struct FlatT5;
       #[automatically_derived]
       impl<'r> ::sqly::sqlx::FromRow<'r, ::sqly::sqlx::postgres::PgRow> for FlatT5 {
           fn from_row(row: &'r ::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<Self> {
               use ::sqly::sqlx::Row as _;
               ::sqly::sqlx::Result::Ok(FlatT5 {})
           }
       }
       #[automatically_derived]
       impl ::core::convert::From<FlatT5> for T5 {
           fn from(row: FlatT5) -> Self {
               T5 {}
           }
       }
       #[automatically_derived]
       impl ::sqly::Flat for T5 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Flat = FlatT5;
       }
       #[automatically_derived]
       impl<'r> ::sqly::sqlx::FromRow<'r, ::sqly::sqlx::postgres::PgRow> for T5 {
           fn from_row(row: &'r ::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<Self> {
               #![allow(non_snake_case)]
               use ::sqly::sqlx::Row as _;
               ::sqly::sqlx::Result::Ok(T5 {})
           }
       }
       #[automatically_derived]
       impl ::sqly::Table for T5 {
           const AUTOMATICALLY_DERIVED: () = ();
       }
  --> tests/debug/table.rs:22:21
   |
22 | #[sqly(table = "t", debug, flat, flat_row, from_flat, from_row)]
   |                     ^^^^^

error: #[allow(non_snake_case)]
       struct FlatT6 {
           t1: (),
           t2: (),
       }
       #[automatically_derived]
       impl<'r> ::sqly::sqlx::FromRow<'r, ::sqly::sqlx::postgres::PgRow> for FlatT6 {
           fn from_row(row: &'r ::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<Self> {
               use ::sqly::sqlx::Row as _;
               ::sqly::sqlx::Result::Ok(FlatT6 {
                   t1: row.try_get("t1")?,
                   t2: row.try_get("t2")?,
               })
           }
       }
       #[automatically_derived]
       impl ::core::convert::From<FlatT6> for T6 {
           fn from(row: FlatT6) -> Self {
               T6 { t1: row.t1, t2: row.t2 }
           }
       }
       #[automatically_derived]
       impl ::sqly::Flat for T6 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Flat = FlatT6;
       }
       #[automatically_derived]
       impl<'r> ::sqly::sqlx::FromRow<'r, ::sqly::sqlx::postgres::PgRow> for T6 {
           fn from_row(row: &'r ::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<Self> {
               #![allow(non_snake_case)]
               use ::sqly::sqlx::Row as _;
               ::sqly::sqlx::Result::Ok(T6 {
                   t1: row.try_get::<(), _>("t1")?,
                   t2: row.try_get::<(), _>("t2")?,
               })
           }
       }
       #[automatically_derived]
       impl ::sqly::Table for T6 {
           const AUTOMATICALLY_DERIVED: () = ();
       }
  --> tests/debug/table.rs:26:21
   |
26 | #[sqly(table = "t", debug, flat, flat_row, from_flat, from_row)]
   |                     ^^^^^

error: #[automatically_derived]
       impl ::sqly::DeleteImpl for DeleteT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = T7;
           type Query<'q, 'a> = ::sqly::sqlx::query::Query<
               'q,
               ::sqly::sqlx::Postgres,
               <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
           >;
           type From<'q, 'a> = (
               &'q str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           type Sql<'a> = (
               &'static str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           fn delete_sql(&self) -> Self::Sql<'_> {
               let arg = (&(self.t1),);
               use ::sqly::sqlx::Arguments as _;
               let mut args = <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments::default();
               args.reserve(
                   1usize,
                   0 + ::sqly::sqlx::Encode::<::sqly::sqlx::Postgres>::size_hint(arg.0),
               );
               let args = ::core::result::Result::Ok(args)
                   .and_then(move |mut args| args.add(arg.0).map(move |()| args));
               ("DELETE FROM t AS \"self\"\nWHERE\n\t\"t1\" = $1", args)
           }
           fn delete_from<'q, 'a>(query: Self::From<'q, 'a>) -> Self::Query<'q, 'a> {
               ::sqly::sqlx::__query_with_result(query.0, query.1)
           }
       }
       #[automatically_derived]
       impl ::sqly::Delete for DeleteT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = <Self as ::sqly::DeleteImpl>::Table;
           type Query<'a> = <Self as ::sqly::DeleteImpl>::Query<'static, 'a> where Self: 'a;
           fn delete(&self) -> Self::Query<'_> {
               <Self as ::sqly::DeleteImpl>::delete_from(
                   <Self as ::sqly::DeleteImpl>::delete_sql(self),
               )
           }
       }
  --> tests/debug/table.rs:34:21
   |
34 | #[sqly(table = "t", debug, delete, insert, select, update)]
   |                     ^^^^^

error: #[automatically_derived]
       impl ::sqly::InsertImpl for InsertT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = T7;
           type Query<'q, 'a> = ::sqly::sqlx::query::Query<
               'q,
               ::sqly::sqlx::Postgres,
               <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
           >;
           type From<'q, 'a> = (
               &'q str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           type Sql<'a> = (
               &'static str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           fn insert_sql(&self) -> Self::Sql<'_> {
               let arg = (&(self.t1), &(self.t2));
               use ::sqly::sqlx::Arguments as _;
               let mut args = <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments::default();
               args.reserve(
                   2usize,
                   0 + ::sqly::sqlx::Encode::<::sqly::sqlx::Postgres>::size_hint(arg.0)
                       + ::sqly::sqlx::Encode::<::sqly::sqlx::Postgres>::size_hint(arg.1),
               );
               let args = ::core::result::Result::Ok(args)
                   .and_then(move |mut args| args.add(arg.0).map(move |()| args))
                   .and_then(move |mut args| args.add(arg.1).map(move |()| args));
               (
                   "INSERT INTO t AS \"self\" (\n\t\"t1\",\n\t\"t2\"\n) VALUES (\n\t$1,\n\t$2\n)",
                   args,
               )
           }
           fn insert_from<'q, 'a>(query: Self::From<'q, 'a>) -> Self::Query<'q, 'a> {
               ::sqly::sqlx::__query_with_result(query.0, query.1)
           }
       }
       #[automatically_derived]
       impl ::sqly::Insert for InsertT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = <Self as ::sqly::InsertImpl>::Table;
           type Query<'a> = <Self as ::sqly::InsertImpl>::Query<'static, 'a> where Self: 'a;
           fn insert(&self) -> Self::Query<'_> {
               <Self as ::sqly::InsertImpl>::insert_from(
                   <Self as ::sqly::InsertImpl>::insert_sql(self),
               )
           }
       }
  --> tests/debug/table.rs:34:21
   |
34 | #[sqly(table = "t", debug, delete, insert, select, update)]
   |                     ^^^^^

error: #[automatically_derived]
       impl ::sqly::SelectImpl for SelectT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = T7;
           type Query<'q, 'a> = ::sqly::sqlx::query::Map<
               'q,
               ::sqly::sqlx::Postgres,
               fn(::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<T7>,
               <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
           >;
           type From<'q, 'a> = (
               &'q str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           type Sql<'a> = (
               &'static str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           fn select_sql(&self) -> Self::Sql<'_> {
               let arg = (&(self.t1),);
               use ::sqly::sqlx::Arguments as _;
               let mut args = <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments::default();
               args.reserve(
                   1usize,
                   0 + ::sqly::sqlx::Encode::<::sqly::sqlx::Postgres>::size_hint(arg.0),
               );
               let args = ::core::result::Result::Ok(args)
                   .and_then(move |mut args| args.add(arg.0).map(move |()| args));
               (
                   "SELECT\n\t\"self\".\"t1\",\n\t\"self\".\"t2\"\nFROM t AS \"self\"\nWHERE\n\t\"self\".\"t1\" = $1",
                   args,
               )
           }
           fn select_from<'q, 'a>(query: Self::From<'q, 'a>) -> Self::Query<'q, 'a> {
               ::sqly::sqlx::__query_with_result(query.0, query.1)
                   .try_map(|row| { ::sqly::sqlx::FromRow::from_row(&row) })
           }
       }
       #[automatically_derived]
       impl ::sqly::Select for SelectT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = <Self as ::sqly::SelectImpl>::Table;
           type Query<'a> = <Self as ::sqly::SelectImpl>::Query<'static, 'a> where Self: 'a;
           fn select(&self) -> Self::Query<'_> {
               <Self as ::sqly::SelectImpl>::select_from(
                   <Self as ::sqly::SelectImpl>::select_sql(self),
               )
           }
       }
  --> tests/debug/table.rs:34:21
   |
34 | #[sqly(table = "t", debug, delete, insert, select, update)]
   |                     ^^^^^

error: #[automatically_derived]
       impl ::sqly::UpdateImpl for UpdateT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = T7;
           type Query<'q, 'a> = ::sqly::sqlx::query::Query<
               'q,
               ::sqly::sqlx::Postgres,
               <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
           >;
           type From<'q, 'a> = (
               &'q str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           type Sql<'a> = (
               &'static str,
               ::core::result::Result<
                   <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments<'a>,
                   ::sqly::sqlx::error::BoxDynError,
               >,
           );
           fn update_sql(&self) -> Self::Sql<'_> {
               let arg = (&(self.t2), &(self.t1));
               use ::sqly::sqlx::Arguments as _;
               let mut args = <::sqly::sqlx::Postgres as ::sqly::sqlx::Database>::Arguments::default();
               args.reserve(
                   2usize,
                   0 + ::sqly::sqlx::Encode::<::sqly::sqlx::Postgres>::size_hint(arg.0)
                       + ::sqly::sqlx::Encode::<::sqly::sqlx::Postgres>::size_hint(arg.1),
               );
               let args = ::core::result::Result::Ok(args)
                   .and_then(move |mut args| args.add(arg.0).map(move |()| args))
                   .and_then(move |mut args| args.add(arg.1).map(move |()| args));
               ("UPDATE t AS \"self\"\nSET\n\t\"t2\" = $1\nWHERE\n\t\"t1\" = $2", args)
           }
           fn update_from<'q, 'a>(query: Self::From<'q, 'a>) -> Self::Query<'q, 'a> {
               ::sqly::sqlx::__query_with_result(query.0, query.1)
           }
       }
       #[automatically_derived]
       impl ::sqly::Update for UpdateT7 {
           const AUTOMATICALLY_DERIVED: () = ();
           type Table = <Self as ::sqly::UpdateImpl>::Table;
           type Query<'a> = <Self as ::sqly::UpdateImpl>::Query<'static, 'a> where Self: 'a;
           fn update(&self) -> Self::Query<'_> {
               <Self as ::sqly::UpdateImpl>::update_from(
                   <Self as ::sqly::UpdateImpl>::update_sql(self),
               )
           }
       }
  --> tests/debug/table.rs:34:21
   |
34 | #[sqly(table = "t", debug, delete, insert, select, update)]
   |                     ^^^^^

error: #[automatically_derived]
       impl<'r> ::sqly::sqlx::FromRow<'r, ::sqly::sqlx::postgres::PgRow> for T7 {
           fn from_row(row: &'r ::sqly::sqlx::postgres::PgRow) -> ::sqly::sqlx::Result<Self> {
               #![allow(non_snake_case)]
               use ::sqly::sqlx::Row as _;
               ::sqly::sqlx::Result::Ok(T7 {
                   t1: row.try_get::<i32, _>("t1")?,
                   t2: row.try_get::<i32, _>("t2")?,
               })
           }
       }
       #[automatically_derived]
       impl ::sqly::Table for T7 {
           const AUTOMATICALLY_DERIVED: () = ();
       }
       #[derive(::sqly::Delete)]
       #[sqly(table = T7, debug)]
       struct DeleteT7 {
           t1: i32,
       }
       #[derive(::sqly::Insert)]
       #[sqly(table = T7, debug)]
       struct InsertT7 {
           t1: i32,
           t2: i32,
       }
       #[derive(::sqly::Select)]
       #[sqly(table = T7, debug)]
       struct SelectT7 {
           t1: i32,
       }
       #[derive(::sqly::Update)]
       #[sqly(table = T7, debug)]
       struct UpdateT7 {
           #[sqly(key)]
           t1: i32,
           t2: i32,
       }
  --> tests/debug/table.rs:34:21
   |
34 | #[sqly(table = "t", debug, delete, insert, select, update)]
   |                     ^^^^^
