/*

This serves as a template for a local playground to test
the examples. Clone the c0_intro folder and put anything
above the main function to try it for yourself.

The #[sqly(print)] and #[sqly(debug)] attributes can be
used to inspect the queries and code generated by sqly at
compile time. Cargo check will emit the output from these
attributes without requiring a database connection.

If you do wish to connect to a real database, either for
compile time checking or for runtime execution, add the
DATABASE_URL to the .env file and add the sqly "checked"
feature to the Cargo.toml, or re-enable default-features.

It is recommended to go through the examples in order, with
the [docs.rs](https://docs.rs/sqly) documentation for exact
definitions and the local playground to experiment further.

*/

#![allow(dead_code)]

use sqly::derive::*;

#[derive(Table, Debug)]
#[sqly(unchecked = types)]
#[sqly(table = "pg_catalog.pg_tables", from_row)]
// #[sqly(debug = warn)]
struct PgTable {
    schemaname: String,
    tablename: String,
    tableowner: String,
    tablespace: Option<String>,
    hasindexes: bool,
    hasrules: bool,
    hastriggers: bool,
    rowsecurity: bool,
}

#[derive(Select)]
#[sqly(table = PgTable)]
#[sqly(filter = "schemaname != 'pg_catalog' AND")]
#[sqly(filter = "schemaname != 'information_schema'")]
// #[sqly(print = warn)]
struct UserPgTables;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenvy::dotenv().expect("dotenv");

    let url = std::env::var("DATABASE_URL").expect("DATABASE_URL");
    let conn = sqlx::postgres::PgPoolOptions::new().connect(&url);
    let db = conn.await.expect("connect");

    let query = UserPgTables.select();
    let res = query.fetch_all(&db).await?;

    println!("{:#?}", res.first());
    println!("{}", res.len());

    Ok(())
}
